# DigiSocialBlock (Nexus Protocol) - Core Data Structure Validation Plan

## 1. Objective

To formulate a detailed implementation plan for adding `Validate() error` methods to the core Go data structures that will be generated from the `echonet_v3_core.proto` definition file. The primary goal is to ensure robust data integrity at the foundational data model level, preventing invalid or inconsistent data from being processed or persisted within the DigiSocialBlock ecosystem.

## 2. Scope

This plan covers the validation logic for all primary data structures defined in `echonet_v3_core.proto`. This includes, but is not limited to, conceptual entities such as:
*   `UserProfile`
*   `ContentPost`
*   `InteractionLog` (e.g., likes, comments, shares)
*   `CommunityGroup`
*   `DigitalAsset` (representing NFTs or other tokenized items)
*   `TransactionRecord` (for value or asset transfers)
*   Any other core message types defined in the Protobuf schema.

The plan will detail the specific validation rules for each field within these structs and outline the error handling strategy.

## 3. Guiding Principles

The design and implementation of this validation logic will adhere to the following core principles:
*   **GIGO Antidote (Garbage In, Garbage Out):** Implement explicit and strict checks to prevent malformed, inconsistent, or invalid data from entering the system.
*   **System Reliability:** Ensure that robust validation contributes to the overall stability, predictability, and trustworthiness of the DigiSocialBlock platform.
*   **Foundation for Testing:** Provide a clear, testable interface for data integrity checks, forming the basis for comprehensive unit and integration testing.
*   **Know Your Core, Keep it Clear:** Validation rules should be explicit, easily understandable, and directly reflect the intended constraints and business logic of the data structures.
*   **Security First (Sense the Landscape, Secure the Solution):** Proactively identify potential data-related vulnerabilities (e.g., excessively long strings, invalid references) and implement checks to mitigate them.
*   **Efficiency:** While thorough, validation should be as efficient as possible to avoid undue performance overhead, especially for frequently accessed or created data types.

---

## 4. Common Validation Rules & Error Handling Strategy

This section outlines common validation patterns that will apply across multiple data structures and the strategy for error reporting.

### 4.1. Common Validation Rules

*   **Identifiers (e.g., `user_id`, `post_id`, `asset_id`):**
    *   **Required:** Typically, all primary identifiers will be mandatory.
    *   **Format:** Must adhere to a standard UUID (Universally Unique Identifier) format (e.g., as generated by `github.com/google/uuid`). A helper function `isValidUUID(id string) bool` might be used.
    *   **Uniqueness:** While `Validate()` on a single struct cannot check for global uniqueness (this is a database/state manager concern), it ensures the ID *format* is valid.
*   **Timestamps (e.g., `created_at`, `updated_at`, `interaction_timestamp`):**
    *   **Required:** Usually mandatory for auditable records.
    *   **Non-Zero:** Must not be the zero value for `time.Time`.
    *   **Reasonable Range:**
        *   Not excessively in the past (e.g., before project epoch/birthdate).
        *   Not excessively in the future (e.g., more than a few minutes/hours ahead of current time, allowing for clock skew). This might require access to a "current time" oracle or be a looser check in stateless validation.
    *   **Logical Order:** For structs with `created_at` and `updated_at`, ensure `updated_at >= created_at`. Similarly for `start_time` and `end_time`.
*   **Strings (e.g., `username`, `display_name`, `text_content`, `description`, `url`):**
    *   **Required/Optional:** Based on field definition in Protobuf (`optional` keyword or presence checks).
    *   **Min/Max Length:** Enforce sensible minimum (e.g., for usernames, names) and maximum lengths (e.g., for text content, bios, URLs) to prevent abuse and ensure database compatibility. These lengths will be defined per field.
    *   **Character Sets:** For specific fields like `username`, define allowed character sets (e.g., alphanumeric, underscores, no spaces, no special characters).
    *   **URL Format:** For fields representing URLs, basic format validation (e.g., using `net/url.ParseRequestURI` and checking scheme).
    *   **Trimming:** Consider if leading/trailing whitespace should be automatically trimmed before validation or if its presence makes the string invalid. (Usually, trimming is done at input, validation checks the result).
*   **Numeric Fields (e.g., `reputation_score`, `amount`, counts):**
    *   **Range:** Enforce min/max values where applicable (e.g., `reputation_score` between -1,000,000 and +1,000,000; `amount` must be non-negative).
*   **Enum Fields (e.g., `UserStatus`, `ContentType`, `VisibilitySetting`):**
    *   **Defined Values:** Must correspond to one of the `int32` values defined for that enum in the Protobuf schema. Check against the generated constants.
    *   The `_value` map generated by `protoc-gen-go` for enums can be used for this check.
*   **Repeated Fields (Lists/Arrays, e.g., `tags` on a `ContentPost`):**
    *   **Max Count:** Limit the maximum number of items in a list (e.g., max 10 tags).
    *   **Individual Item Validation:** Each item in the list must also be validated (e.g., each tag string for length and content).
*   **Map Fields (e.g., `metadata` on `DigitalAsset`):**
    *   **Max Count:** Limit the maximum number of key-value pairs.
    *   **Key Constraints:** Max length, allowed characters for keys. Keys usually cannot be empty.
    *   **Value Constraints:** Max length/size for values.
*   **Foreign Key References (e.g., `author_id` in `ContentPost` referencing `UserProfile.user_id`):**
    *   `Validate()` on a single struct can only check if the ID field itself is present and in the correct format (e.g., valid UUID).
    *   Verifying the *existence* of the referenced entity is a stateful operation, typically handled by the service layer or state manager when creating/updating the referencing entity.

### 4.2. Error Handling Strategy

*   **Return Type:** All `Validate() error` methods will return a single `error`. A `nil` return indicates successful validation.
*   **Dedicated Errors Package:** A new Go package, tentatively named `internal/nexuserrors` (or similar, specific to DigiSocialBlock), will be created to house all custom error types and variables.
    *   This promotes consistency and allows for type-checking of errors (e.g., using `errors.Is()`).
*   **Specific Error Variables:** For common validation failures, specific error variables will be defined (e.g., `var ErrMissingField = errors.New("required field is missing")`).
*   **Typed Errors (Optional but Recommended):** Consider defining custom error structs that implement the `error` interface if more context needs to be carried with errors (e.g., which field failed, what value was problematic).
    ```go
    // Example in internal/nexuserrors/errors.go
    // type ValidationError struct {
    //     Field   string
    //     Message string
    //     Cause   error // Optional underlying cause
    // }
    // func (e *ValidationError) Error() string { /* ... */ }
    // func (e *ValidationError) Unwrap() error { return e.Cause }
    ```
    For now, plan will assume use of `errors.New` for distinct error variables, and `fmt.Errorf("message with details: %w", specificErrorVar)` for wrapping and adding context.
*   **Clarity:** Error messages should be clear and informative enough to help developers (and potentially users, via API responses) understand the nature of the validation failure.
*   **First Failure Principle:** Generally, `Validate()` methods should return on the first validation failure encountered for simplicity and performance. Aggregating all validation errors can be complex and is often not needed for internal validation.

---

## 5. Per-Struct Validation Logic Specification

The following sections detail the specific validation rules for each primary Go data structure generated from `echonet_v3_core.proto`. All error messages should be clear, and errors should be returned from the `internal/nexuserrors` package.

*(Actual struct and field names will depend on the final `echonet_v3_core.proto` definitions. The following are illustrative examples based on common social protocol needs.)*

### 5.1. `UserProfile.Validate() error`

The `Validate()` method for the `UserProfile` struct will implement the following checks:

*   **`user_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string (e.g., parseable by `uuid.Parse()`).
    *   *Error: `ErrMissingField` (for "user_id"), `ErrInvalidUUID` (for "user_id")*
*   **`username` (string):**
    *   **Required:** Must not be an empty string.
    *   **Length:** Min length (e.g., 3 characters), Max length (e.g., 30 characters).
    *   **Character Set:** Must only contain alphanumeric characters and underscores (e.g., `^[a-zA-Z0-9_]+$`). No spaces or other special characters.
    *   *Error: `ErrMissingField` (for "username"), `ErrStringTooShort` (for "username"), `ErrStringTooLong` (for "username"), `ErrInvalidCharacters` (for "username")*
*   **`display_name` (string, optional):**
    *   **Length:** If present (not empty), max length (e.g., 50 characters).
    *   *Error: `ErrStringTooLong` (for "display_name")*
*   **`bio` (string, optional):**
    *   **Length:** If present, max length (e.g., 160 characters).
    *   *Error: `ErrStringTooLong` (for "bio")*
*   **`profile_picture_url` (string, optional):**
    *   **Format:** If present, must be a valid URL format (parsable by `net/url.ParseRequestURI` and has a scheme like http/https).
    *   **Length:** If present, max length (e.g., 2048 characters).
    *   *Error: `ErrInvalidURL` (for "profile_picture_url"), `ErrStringTooLong` (for "profile_picture_url")*
*   **`created_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time.
    *   *Error: `ErrMissingField` (for "created_at"), `ErrInvalidTimestamp` (for "created_at")*
*   **`updated_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before `created_at`.
    *   *Error: `ErrMissingField` (for "updated_at"), `ErrInvalidTimestamp` (for "updated_at", e.g., "updated_at cannot be before created_at")*
*   **`reputation_score` (int64/float64):**
    *   **Range:** Must be within a defined range (e.g., -1,000,000 to +1,000,000).
    *   *Error: `ErrValueOutOfRange` (for "reputation_score")*
*   **`status` (enum, e.g., `UserStatus`):**
    *   **Validity:** Must be one of the defined enum values for `UserStatus` (e.g., `USER_STATUS_ACTIVE`, `USER_STATUS_SUSPENDED`, `USER_STATUS_DEACTIVATED`). Check against the `_UserStatus_value` map.
    *   *Error: `ErrUnknownEnumValue` (for "status")*

*(This pattern will be repeated for other core structs.)*

### 5.2. `ContentPost.Validate() error`

The `Validate()` method for the `ContentPost` struct will implement the following checks:

*   **`post_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "post_id"), `ErrInvalidUUID` (for "post_id")*
*   **`author_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string (conceptually references `UserProfile.user_id`).
    *   *Error: `ErrMissingField` (for "author_id"), `ErrInvalidUUID` (for "author_id")*
*   **`content_type` (enum, e.g., `ContentType`):**
    *   **Validity:** Must be one of the defined enum values for `ContentType` (e.g., `CONTENT_TYPE_TEXT`, `CONTENT_TYPE_IMAGE`, `CONTENT_TYPE_VIDEO`).
    *   *Error: `ErrUnknownEnumValue` (for "content_type")*
*   **`text_content` (string, conditional):**
    *   **Required if `content_type` is `CONTENT_TYPE_TEXT`:** Must not be empty in this case.
    *   **Length:** If present, max length (e.g., 10,000 characters).
    *   **Not Allowed if `content_type` is IMAGE/VIDEO:** Should ideally be empty or not present if content is primarily media.
    *   *Error: `ErrMissingField` (for "text_content" when required), `ErrStringTooLong` (for "text_content"), `ErrUnexpectedField` (for "text_content" if media type)*
*   **`media_url` (string, conditional):**
    *   **Required if `content_type` is `CONTENT_TYPE_IMAGE` or `CONTENT_TYPE_VIDEO`:** Must not be empty in these cases.
    *   **Format:** If present, must be a valid URL.
    *   **Length:** If present, max length (e.g., 2048 characters).
    *   **Not Allowed if `content_type` is TEXT:** Should ideally be empty or not present.
    *   *Error: `ErrMissingField` (for "media_url" when required), `ErrInvalidURL` (for "media_url"), `ErrStringTooLong` (for "media_url"), `ErrUnexpectedField` (for "media_url" if text type)*
*   **`visibility` (enum, e.g., `VisibilitySetting`):**
    *   **Validity:** Must be one of the defined enum values for `VisibilitySetting` (e.g., `VISIBILITY_PUBLIC`, `VISIBILITY_FRIENDS_ONLY`, `VISIBILITY_PRIVATE`).
    *   *Error: `ErrUnknownEnumValue` (for "visibility")*
*   **`tags` (repeated string, optional):**
    *   **Max Count:** If present, limit the number of tags (e.g., max 10 tags).
    *   **Individual Tag Validation:** Each string in the `tags` list:
        *   Must not be empty.
        *   Max length (e.g., 25 characters).
        *   Allowed characters (e.g., alphanumeric, no spaces).
    *   *Error: `ErrTooManyItems` (for "tags"), `ErrEmptyListItem` (for "tags[]"), `ErrStringTooLong` (for "tags[]"), `ErrInvalidCharacters` (for "tags[]")*
*   **`created_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time.
    *   *Error: `ErrMissingField` (for "created_at"), `ErrInvalidTimestamp` (for "created_at")*
*   **`updated_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before `created_at`.
    *   *Error: `ErrMissingField` (for "updated_at"), `ErrInvalidTimestamp` (for "updated_at")*
*   **`community_group_id` (string/UUID, optional):**
    *   **Format:** If present (not empty), must be a valid UUID string (conceptually references `CommunityGroup.group_id`).
    *   *Error: `ErrInvalidUUID` (for "community_group_id")*
*   **`parent_post_id` (string/UUID, optional):**
    *   **Format:** If present (not empty), must be a valid UUID string (conceptually references another `ContentPost.post_id`, e.g., for replies).
    *   **Logic:** Cannot be equal to its own `post_id`.
    *   *Error: `ErrInvalidUUID` (for "parent_post_id"), `ErrInvalidReference` (for "parent_post_id", e.g., "parent_post_id cannot be self")*

### 5.3. `InteractionLog.Validate() error`

The `Validate()` method for the `InteractionLog` struct (representing likes, comments, shares, etc.) will implement the following checks:

*   **`interaction_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "interaction_id"), `ErrInvalidUUID` (for "interaction_id")*
*   **`user_id` (string/UUID):**
    *   **Required:** Must not be an empty string (identifies the user who performed the interaction).
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "user_id"), `ErrInvalidUUID` (for "user_id")*
*   **`target_content_id` (string/UUID):**
    *   **Required:** Must not be an empty string (identifies the `ContentPost`, `Comment`, or other interactable item).
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "target_content_id"), `ErrInvalidUUID` (for "target_content_id")*
*   **`target_content_type` (enum, e.g., `InteractableContentType`):**
    *   **Required:** Must be a defined enum value (e.g., `POST`, `COMMENT`, `ASSET`).
    *   *Error: `ErrMissingField` (for "target_content_type"), `ErrUnknownEnumValue` (for "target_content_type")*
*   **`interaction_type` (enum, e.g., `InteractionType`):**
    *   **Required:** Must be one of the defined enum values (e.g., `INTERACTION_TYPE_LIKE`, `INTERACTION_TYPE_COMMENT`, `INTERACTION_TYPE_SHARE`, `INTERACTION_TYPE_VIEW`).
    *   *Error: `ErrMissingField` (for "interaction_type"), `ErrUnknownEnumValue` (for "interaction_type")*
*   **`comment_text` (string, conditional):**
    *   **Required if `interaction_type` is `INTERACTION_TYPE_COMMENT`:** Must not be empty in this case.
    *   **Length:** If present, max length (e.g., 2000 characters).
    *   **Not Allowed for other types like LIKE/SHARE:** Should be empty or not present.
    *   *Error: `ErrMissingField` (for "comment_text" when required), `ErrStringTooLong` (for "comment_text"), `ErrUnexpectedField` (for "comment_text" on non-comment types)*
*   **`timestamp` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time or excessively in the future.
    *   *Error: `ErrMissingField` (for "timestamp"), `ErrInvalidTimestamp` (for "timestamp")*
*   **`parent_interaction_id` (string/UUID, optional):**
    *   **Format:** If present (e.g., for a reply to a comment), must be a valid UUID string.
    *   **Logic:** Cannot be equal to its own `interaction_id`.
    *   *Error: `ErrInvalidUUID` (for "parent_interaction_id"), `ErrInvalidReference` (for "parent_interaction_id")*

### 5.4. `CommunityGroup.Validate() error`

The `Validate()` method for the `CommunityGroup` struct will implement the following checks:

*   **`group_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "group_id"), `ErrInvalidUUID` (for "group_id")*
*   **`name` (string):**
    *   **Required:** Must not be an empty string.
    *   **Length:** Min length (e.g., 3 characters), Max length (e.g., 100 characters).
    *   *Error: `ErrMissingField` (for "name"), `ErrStringTooShort` (for "name"), `ErrStringTooLong` (for "name")*
*   **`description` (string, optional):**
    *   **Length:** If present, max length (e.g., 500 characters).
    *   *Error: `ErrStringTooLong` (for "description")*
*   **`creator_id` (string/UUID):**
    *   **Required:** Must not be an empty string (identifies the `UserProfile` who created the group).
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "creator_id"), `ErrInvalidUUID` (for "creator_id")*
*   **`privacy_setting` (enum, e.g., `GroupPrivacy`):**
    *   **Validity:** Must be one of the defined enum values for `GroupPrivacy` (e.g., `GROUP_PRIVACY_PUBLIC`, `GROUP_PRIVACY_PRIVATE_INVITE_ONLY`, `GROUP_PRIVACY_PRIVATE_REQUEST_TO_JOIN`).
    *   *Error: `ErrUnknownEnumValue` (for "privacy_setting")*
*   **`created_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time.
    *   *Error: `ErrMissingField` (for "created_at"), `ErrInvalidTimestamp` (for "created_at")*
*   **`updated_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before `created_at`.
    *   *Error: `ErrMissingField` (for "updated_at"), `ErrInvalidTimestamp` (for "updated_at")*
*   **`member_count` (int64, read-only or server-managed):**
    *   **Range:** Must be non-negative. (This field is likely managed by the server, but basic validation can ensure it's not negative if present on input for some reason).
    *   *Error: `ErrValueOutOfRange` (for "member_count", e.g., "member_count cannot be negative")*
*   **`group_avatar_url` (string, optional):**
    *   **Format:** If present, must be a valid URL.
    *   **Length:** If present, max length (e.g., 2048 characters).
    *   *Error: `ErrInvalidURL` (for "group_avatar_url"), `ErrStringTooLong` (for "group_avatar_url")*

### 5.5. `DigitalAsset.Validate() error`

The `Validate()` method for the `DigitalAsset` struct (representing NFTs, badges, or other tokenized items) will implement the following checks:

*   **`asset_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "asset_id"), `ErrInvalidUUID` (for "asset_id")*
*   **`owner_id` (string/UUID):**
    *   **Required:** Must not be an empty string (identifies the `UserProfile` who owns the asset).
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "owner_id"), `ErrInvalidUUID` (for "owner_id")*
*   **`asset_type` (enum, e.g., `AssetType`):**
    *   **Validity:** Must be one of the defined enum values for `AssetType` (e.g., `ASSET_TYPE_NFT_IMAGE`, `ASSET_TYPE_BADGE`, `ASSET_TYPE_TICKET`).
    *   *Error: `ErrUnknownEnumValue` (for "asset_type")*
*   **`name` (string):**
    *   **Required:** Must not be an empty string.
    *   **Length:** Min length (e.g., 1 character), Max length (e.g., 100 characters).
    *   *Error: `ErrMissingField` (for "name"), `ErrStringTooShort` (for "name"), `ErrStringTooLong` (for "name")*
*   **`description` (string, optional):**
    *   **Length:** If present, max length (e.g., 1000 characters).
    *   *Error: `ErrStringTooLong` (for "description")*
*   **`asset_url_or_identifier` (string):**
    *   **Required:** Must not be an empty string. This could be a URL to media (like IPFS) or an internal identifier scheme.
    *   **Format:** If it's a URL, must be a valid URL format. If it's an internal ID, must match a defined pattern.
    *   **Length:** Max length (e.g., 2048 characters).
    *   *Error: `ErrMissingField` (for "asset_url_or_identifier"), `ErrInvalidURL` (if URL format expected and fails), `ErrInvalidFormat` (if internal ID format fails), `ErrStringTooLong` (for "asset_url_or_identifier")*
*   **`metadata` (map<string, string> or map<string, google.protobuf.Value>, optional):**
    *   **Max Count:** If present, limit the number of key-value pairs (e.g., max 50).
    *   **Key Constraints:** Keys must not be empty, max length (e.g., 64 characters).
    *   **Value Constraints:** Values max length/size (e.g., 256 characters/bytes if string; specific validation if `google.protobuf.Value`).
    *   *Error: `ErrTooManyItems` (for "metadata map"), `ErrInvalidMetadataKey`, `ErrInvalidMetadataValue` (or `ErrStringTooLong` for string values)*
*   **`created_at` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time.
    *   *Error: `ErrMissingField` (for "created_at"), `ErrInvalidTimestamp` (for "created_at")*
*   **`supply` (int64, optional, for fungible-like assets or limited edition NFTs):**
    *   **Range:** If present and greater than 0, must be within a sensible range (e.g., > 0, <= max_supply_cap). If 0 or -1, could indicate infinite or not applicable.
    *   *Error: `ErrValueOutOfRange` (for "supply")*
*   **`is_transferable` (bool, optional):**
    *   No specific validation other than boolean type.

### 5.6. `TransactionRecord.Validate() error`

The `Validate()` method for the `TransactionRecord` struct (logging value/asset transfers, mints, burns) will implement the following checks:

*   **`transaction_id` (string/UUID):**
    *   **Required:** Must not be an empty string.
    *   **Format:** Must be a valid UUID string.
    *   *Error: `ErrMissingField` (for "transaction_id"), `ErrInvalidUUID` (for "transaction_id")*
*   **`from_user_id` (string/UUID):**
    *   **Required:** Must not be an empty string. Could be a user's UUID or a special system/contract UUID (e.g., for minting).
    *   **Format:** Must be a valid UUID string or a recognized system identifier pattern.
    *   *Error: `ErrMissingField` (for "from_user_id"), `ErrInvalidUUID` (for "from_user_id")*
*   **`to_user_id` (string/UUID):**
    *   **Required:** Must not be an empty string. Could be a user's UUID or a special system/contract UUID (e.g., for burning).
    *   **Format:** Must be a valid UUID string or a recognized system identifier pattern.
    *   *Error: `ErrMissingField` (for "to_user_id"), `ErrInvalidUUID` (for "to_user_id")*
*   **`asset_id` (string/UUID, optional):**
    *   **Format:** If present (not empty), must be a valid UUID string (references `DigitalAsset.asset_id`).
    *   *Error: `ErrInvalidUUID` (for "asset_id")*
*   **`transaction_type` (enum, e.g., `TransactionType` specific to assets/value):**
    *   **Validity:** Must be one of the defined enum values (e.g., `TRANSACTION_TYPE_TRANSFER_ASSET`, `TRANSACTION_TYPE_MINT_ASSET`, `TRANSACTION_TYPE_BURN_ASSET`, `TRANSACTION_TYPE_TRANSFER_FT`).
    *   *Error: `ErrUnknownEnumValue` (for "transaction_type")*
*   **`value_or_amount` (string for high precision decimal, or int64 for smallest unit):**
    *   **Required if `transaction_type` implies value transfer/mint/burn** (e.g., not for a simple asset ownership change without payment).
    *   **Format/Range:** If string, must be parsable as a positive decimal. If int64, must be non-negative.
    *   *Error: `ErrMissingField` (for "value_or_amount" when required), `ErrInvalidFormat` (for "value_or_amount"), `ErrValueOutOfRange` (for "value_or_amount", e.g. negative)*
*   **`currency_or_token_id` (string):**
    *   **Required if `value_or_amount` is present and > 0.** Identifies the currency (e.g., "USD", "POINTS") or the fungible token ID.
    *   **Length/Format:** Min/max length, allowed characters or specific format if it's a token UUID.
    *   *Error: `ErrMissingField` (for "currency_or_token_id" when required), `ErrStringTooShort`/`Long`, `ErrInvalidFormat`*
*   **`timestamp` (google.protobuf.Timestamp/time.Time):**
    *   **Required:** Must not be the zero value.
    *   **Range:** Must not be before a defined project epoch start time.
    *   *Error: `ErrMissingField` (for "timestamp"), `ErrInvalidTimestamp` (for "timestamp")*
*   **`status` (enum, e.g., `TransactionStatus`):**
    *   **Validity:** Must be one of the defined enum values (e.g., `TRANSACTION_STATUS_PENDING`, `TRANSACTION_STATUS_COMPLETED`, `TRANSACTION_STATUS_FAILED`, `TRANSACTION_STATUS_CANCELLED`).
    *   *Error: `ErrUnknownEnumValue` (for "status")*
*   **`related_interaction_id` (string/UUID, optional):**
    *   **Format:** If present (not empty), must be a valid UUID string (e.g., linking a tip to a specific `InteractionLog.interaction_id`).
    *   *Error: `ErrInvalidUUID` (for "related_interaction_id")*
*   **`memo_or_description` (string, optional):**
    *   **Length:** If present, max length (e.g., 256 characters).
    *   *Error: `ErrStringTooLong` (for "memo_or_description")*

---

## 6. Unit Testing `Validate()` Methods

Robust unit testing is essential to ensure the correctness and effectiveness of the implemented `Validate()` methods. This section outlines the strategy for these tests.

*   **Dedicated Test Files:** Each Go file containing the Protobuf-generated structs and their `Validate()` methods (e.g., `user_profile.pb.go`, `content_post.pb.go`) will have a corresponding test file (e.g., `user_profile_test.go`, `content_post_test.go`).
*   **Test Function per `Validate()` Method:** For each struct `MessageName` with a `MessageName.Validate() error` method, a dedicated test function (e.g., `TestUserProfile_Validate(t *testing.T)`) will be created.
*   **Table-Driven Tests:** Utilize table-driven tests (test tables) for each `Validate()` method to cover multiple scenarios efficiently. Each entry in the table will represent a distinct test case and include:
    *   `name` (string): A descriptive name for the test case (e.g., "valid profile", "username missing", "username too short", "username too long", "invalid character in username").
    *   `instance` (struct type): An instance of the struct being tested, configured to meet the specific test case conditions (valid or invalid).
    *   `wantErr` (bool): A boolean indicating whether an error is expected from the `Validate()` call.
    *   `expectedErrType` (error, optional): If `wantErr` is true, this field will hold the specific error variable from the `internal/nexuserrors` package that is expected to be returned (or wrapped by the returned error). This allows for `errors.Is(err, expectedErrType)` assertions.
*   **Comprehensive Coverage:**
    *   **Valid Cases:** At least one positive test case demonstrating that a correctly populated instance of the struct passes validation (i.e., `Validate()` returns `nil`).
    *   **Invalid Cases (Negative Testing):** For *every distinct validation rule and potential error path* defined in Section 5 (Per-Struct Validation Logic Specification), one or more specific negative test cases MUST be created. This ensures that each validation check is working as intended.
        *   Examples: Missing required fields, fields with values outside defined min/max lengths, invalid character sets, invalid URL formats, invalid UUID formats, enum values not in the defined set, inconsistent timestamps (`updated_at` < `created_at`), numeric values out of range, too many items in a list, invalid map keys/values.
    *   **Boundary Conditions:** Test values at the boundaries of valid ranges (e.g., strings at exact min/max length, numbers at min/max allowed values).
*   **Error Verification:**
    *   When an error is expected (`wantErr == true`), the test must assert that an error is indeed returned (`err != nil`).
    *   Furthermore, it must verify that the returned error is of the expected type using `errors.Is(err, expectedErrType)`. This confirms that the correct specific error from `internal/nexuserrors` is being used.
*   **Test Independence:** Each test case should be independent and not rely on the state or outcome of other test cases. Test functions should set up their required struct instances locally.
*   **Clarity of Failure Messages:** Test assertions (e.g., `t.Errorf(...)`) should provide clear and informative messages upon failure, indicating what condition failed, what was expected, and what was actually received.
*   **Reference to Detailed Test Case Document:**
    *   While this document outlines the *strategy* and *types* of test cases, the exhaustive list of individual test scenarios for each field of each struct would be maintained in a separate, more detailed document, conceptually named `testing_strategies/digisocial_core_data_unit_tests.md`. This `digisocial_core_data_validation_plan.md` confirms the commitment to this level of testing.
*   **CI/CD Integration:** All unit tests will be part of the automated Continuous Integration/Continuous Delivery (CI/CD) pipeline, ensuring they are run on every code change to catch regressions early.

---
*(End of Document: DigiSocialBlock - Core Data Structure Validation Plan)*
